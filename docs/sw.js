var __wpo = {
  "assets": {
    "main": [
      "./86ed9bd1bfba994a3dca4bb2b655beeb.svg",
      "./fonts/MaterialIcons-Regular.woff2",
      "./fonts/MaterialIcons-Regular.eot",
      "./fonts/MaterialIcons-Regular.woff",
      "./fonts/MaterialIcons-Regular.ttf",
      "./0.c5a2e13daa6635ca851b.js",
      "./1.fd784542889dbe9ad4fb.js",
      "./data.9c757e412bbd39da0a13.js",
      "./jsondata0.a9d3bb731a59f480f874.js",
      "./jsondata1.5afb4f172a9f00a5145a.js",
      "./main.a57902b95d198443e5ba.css",
      "./main.e928cec6554150d92029.js",
      "./vendors~view.7594b7806ebd35d1ec12.js",
      "./view.e13945d3d6bd3589f4f2.css",
      "./view.01990be7d77a6e1a3328.js",
      "./",
      "./manifest.fc4605d241938822f6cbeef49db003d0.json",
      "./icon_1024x1024.d7ffd9577c1d65963ea9fa2ca73a50b0.png",
      "./icon_512x512.0783d2ee77e56b2e321171182c048de3.png",
      "./icon_384x384.e37a56655c84b92b9684cb8b00909a03.png",
      "./icon_256x256.46e148755db0694d96a005706477d4c0.png",
      "./icon_192x192.67874b885ed8a71ad804e6535c696968.png",
      "./icon_128x128.4d27bf2d0fabea2d3014891b3c0c7452.png",
      "./icon_96x96.3b79a2f82ac4bf54461ecd973cab1171.png",
      "./icon_1024x1024.86ed9bd1bfba994a3dca4bb2b655beeb.svg",
      "./icon_512x512.86ed9bd1bfba994a3dca4bb2b655beeb.svg",
      "./icon_384x384.86ed9bd1bfba994a3dca4bb2b655beeb.svg",
      "./icon_256x256.86ed9bd1bfba994a3dca4bb2b655beeb.svg",
      "./icon_192x192.86ed9bd1bfba994a3dca4bb2b655beeb.svg",
      "./icon_128x128.86ed9bd1bfba994a3dca4bb2b655beeb.svg",
      "./icon_96x96.86ed9bd1bfba994a3dca4bb2b655beeb.svg"
    ],
    "additional": [],
    "optional": []
  },
  "externals": [],
  "hashesMap": {
    "1fe24d8d357c509791ce4c4c63bd9b2402583dfb": "./icon_96x96.86ed9bd1bfba994a3dca4bb2b655beeb.svg",
    "308ee3580a4a34bd230025d460762d53b5344efc": "./fonts/MaterialIcons-Regular.woff2",
    "b28698262d8d8766c7c1bede47059ebea19a90a0": "./fonts/MaterialIcons-Regular.eot",
    "951adc0458f2ead8495da26886b1f1284a716eaa": "./fonts/MaterialIcons-Regular.woff",
    "b2091f9964be16d1065d5afee6d0b258fe29a5ac": "./fonts/MaterialIcons-Regular.ttf",
    "ea85df08c0158ace74c823d6f6eb20840cf67bda": "./0.c5a2e13daa6635ca851b.js",
    "6d077513bc5c884289616b5d4f6c5ca7a38a7a0d": "./1.fd784542889dbe9ad4fb.js",
    "b828abc7cdf3b558b5ee2aaa14663181d746e5c5": "./data.9c757e412bbd39da0a13.js",
    "45676f36da88824a11c3463d205d880b764a282b": "./jsondata0.a9d3bb731a59f480f874.js",
    "c1d77192c159c1494df8da576c18392654b2196d": "./jsondata1.5afb4f172a9f00a5145a.js",
    "b1667b90760e8a2e9d485a5856b1d1921ec33a29": "./main.a57902b95d198443e5ba.css",
    "afebdabf120ecdf7d91a11be96fc41728c82fd73": "./main.e928cec6554150d92029.js",
    "f23f365f20854ee0e452bb6d4f1b90993d9b3182": "./vendors~view.7594b7806ebd35d1ec12.js",
    "07a58b850adeb33867e84550056b692eee5f13d0": "./view.e13945d3d6bd3589f4f2.css",
    "1152c0416bca4f5aaeea265542560b7f3d908a39": "./view.01990be7d77a6e1a3328.js",
    "3f50188c55a6b401f55e70e7e01c094e42670bfa": "./",
    "a0c902d48054485809ace111004abd221d830d09": "./manifest.fc4605d241938822f6cbeef49db003d0.json",
    "57b6e4d814d6aa4cab9a4ce3470a6fde679a853c": "./icon_1024x1024.d7ffd9577c1d65963ea9fa2ca73a50b0.png",
    "81d57b1ea95677099e86fe52195f96e6494d9608": "./icon_512x512.0783d2ee77e56b2e321171182c048de3.png",
    "b8e1b3d7dc6c63cf95bf3ec9531cb2a133a3a0a5": "./icon_384x384.e37a56655c84b92b9684cb8b00909a03.png",
    "86b6be0facea50a8e9b1a40d10fc8da2a0141e9b": "./icon_256x256.46e148755db0694d96a005706477d4c0.png",
    "715f3dd223a5bf6e967ca2a1bfbb2d2895a6ccbb": "./icon_192x192.67874b885ed8a71ad804e6535c696968.png",
    "8bf93b65214a3cfb034c05a1c0e8c5ceec3db216": "./icon_128x128.4d27bf2d0fabea2d3014891b3c0c7452.png",
    "5ecf3d86eb6e87d5246ae5ad6cc9b7e6657ffa00": "./icon_96x96.3b79a2f82ac4bf54461ecd973cab1171.png"
  },
  "strategy": "changed",
  "responseStrategy": "cache-first",
  "version": "2020-1-26 20:28:59",
  "name": "webpack-offline:MI_Chatnoir",
  "pluginVersion": "5.0.7",
  "relativePaths": true
};

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%7B%22data_var_name%22%3A%22__wpo%22%2C%22cacheMaps%22%3A%5B%7B%22match%22%3A%22function%28url%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20if%20%28url.pathname%20%3D%3D%3D%20location.pathname%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20return%20new%20URL%28%5C%22/Chatnoir/%5C%22%2C%20location%29%3B%5Cn%20%20%20%20%20%20%20%20%7D%22%2C%22to%22%3Anull%2C%22requestTypes%22%3A%5B%22navigate%22%5D%7D%5D%2C%22navigationPreload%22%3A%22false%22%7D!./src/js/sw-img.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%7B%22data_var_name%22%3A%22__wpo%22%2C%22cacheMaps%22%3A%5B%7B%22match%22%3A%22function%28url%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20if%20%28url.pathname%20%3D%3D%3D%20location.pathname%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20return%20new%20URL%28%5C%22/Chatnoir/%5C%22%2C%20location%29%3B%5Cn%20%20%20%20%20%20%20%20%7D%22%2C%22to%22%3Anull%2C%22requestTypes%22%3A%5B%22navigate%22%5D%7D%5D%2C%22navigationPreload%22%3A%22false%22%7D!./src/js/sw-img.js":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%7B%22data_var_name%22%3A%22__wpo%22%2C%22cacheMaps%22%3A%5B%7B%22match%22%3A%22function%28url%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20if%20%28url.pathname%20%3D%3D%3D%20location.pathname%29%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20return%20new%20URL%28%5C%22/Chatnoir/%5C%22%2C%20location%29%3B%5Cn%20%20%20%20%20%20%20%20%7D%22%2C%22to%22%3Anull%2C%22requestTypes%22%3A%5B%22navigate%22%5D%7D%5D%2C%22navigationPreload%22%3A%22false%22%7D!./src/js/sw-img.js ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var waitUntil = ExtendableEvent.prototype.waitUntil;\n  var respondWith = FetchEvent.prototype.respondWith;\n  var promisesMap = new WeakMap();\n\n  ExtendableEvent.prototype.waitUntil = function (promise) {\n    var extendableEvent = this;\n    var promises = promisesMap.get(extendableEvent);\n\n    if (promises) {\n      promises.push(Promise.resolve(promise));\n      return;\n    }\n\n    promises = [Promise.resolve(promise)];\n    promisesMap.set(extendableEvent, promises);\n\n    // call original method\n    return waitUntil.call(extendableEvent, Promise.resolve().then(function processPromises() {\n      var len = promises.length;\n\n      // wait for all to settle\n      return Promise.all(promises.map(function (p) {\n        return p[\"catch\"](function () {});\n      })).then(function () {\n        // have new items been added? If so, wait again\n        if (promises.length != len) return processPromises();\n        // we're done!\n        promisesMap[\"delete\"](extendableEvent);\n        // reject if one of the promises rejected\n        return Promise.all(promises);\n      });\n    }));\n  };\n\n  FetchEvent.prototype.respondWith = function (promise) {\n    this.waitUntil(promise);\n    return respondWith.call(this, promise);\n  };\n})();;\n        'use strict';\n\nif (typeof DEBUG === 'undefined') {\n  var DEBUG = false;\n}\n\nfunction WebpackServiceWorker(params, helpers) {\n  var cacheMaps = helpers.cacheMaps;\n  // navigationPreload: true, { map: (URL) => URL, test: (URL) => boolean }\n  var navigationPreload = helpers.navigationPreload;\n\n  // (update)strategy: changed, all\n  var strategy = params.strategy;\n  // responseStrategy: cache-first, network-first\n  var responseStrategy = params.responseStrategy;\n\n  var assets = params.assets;\n\n  var hashesMap = params.hashesMap;\n  var externals = params.externals;\n\n  var prefetchRequest = params.prefetchRequest || {\n    credentials: 'same-origin',\n    mode: 'cors'\n  };\n\n  var CACHE_PREFIX = params.name;\n  var CACHE_TAG = params.version;\n  var CACHE_NAME = CACHE_PREFIX + ':' + CACHE_TAG;\n\n  var PRELOAD_CACHE_NAME = CACHE_PREFIX + '$preload';\n  var STORED_DATA_KEY = '__offline_webpack__data';\n\n  mapAssets();\n\n  var allAssets = [].concat(assets.main, assets.additional, assets.optional);\n\n  self.addEventListener('install', function (event) {\n    console.log('[SW]:', 'Install event');\n\n    var installing = undefined;\n\n    if (strategy === 'changed') {\n      installing = cacheChanged('main');\n    } else {\n      installing = cacheAssets('main');\n    }\n\n    event.waitUntil(installing);\n  });\n\n  self.addEventListener('activate', function (event) {\n    console.log('[SW]:', 'Activate event');\n\n    var activation = cacheAdditional();\n\n    // Delete all assets which name starts with CACHE_PREFIX and\n    // is not current cache (CACHE_NAME)\n    activation = activation.then(storeCacheData);\n    activation = activation.then(deleteObsolete);\n    activation = activation.then(function () {\n      if (self.clients && self.clients.claim) {\n        return self.clients.claim();\n      }\n    });\n\n    if (navigationPreload && self.registration.navigationPreload) {\n      activation = Promise.all([activation, self.registration.navigationPreload.enable()]);\n    }\n\n    event.waitUntil(activation);\n  });\n\n  function cacheAdditional() {\n    if (!assets.additional.length) {\n      return Promise.resolve();\n    }\n\n    if (DEBUG) {\n      console.log('[SW]:', 'Caching additional');\n    }\n\n    var operation = undefined;\n\n    if (strategy === 'changed') {\n      operation = cacheChanged('additional');\n    } else {\n      operation = cacheAssets('additional');\n    }\n\n    // Ignore fail of `additional` cache section\n    return operation['catch'](function (e) {\n      console.error('[SW]:', 'Cache section `additional` failed to load');\n    });\n  }\n\n  function cacheAssets(section) {\n    var batch = assets[section];\n\n    return caches.open(CACHE_NAME).then(function (cache) {\n      return addAllNormalized(cache, batch, {\n        bust: params.version,\n        request: prefetchRequest,\n        failAll: section === 'main'\n      });\n    }).then(function () {\n      logGroup('Cached assets: ' + section, batch);\n    })['catch'](function (e) {\n      console.error(e);\n      throw e;\n    });\n  }\n\n  function cacheChanged(section) {\n    return getLastCache().then(function (args) {\n      if (!args) {\n        return cacheAssets(section);\n      }\n\n      var lastCache = args[0];\n      var lastKeys = args[1];\n      var lastData = args[2];\n\n      var lastMap = lastData.hashmap;\n      var lastVersion = lastData.version;\n\n      if (!lastData.hashmap || lastVersion === params.version) {\n        return cacheAssets(section);\n      }\n\n      var lastHashedAssets = Object.keys(lastMap).map(function (hash) {\n        return lastMap[hash];\n      });\n\n      var lastUrls = lastKeys.map(function (req) {\n        var url = new URL(req.url);\n        url.search = '';\n        url.hash = '';\n\n        return url.toString();\n      });\n\n      var sectionAssets = assets[section];\n      var moved = [];\n      var changed = sectionAssets.filter(function (url) {\n        if (lastUrls.indexOf(url) === -1 || lastHashedAssets.indexOf(url) === -1) {\n          return true;\n        }\n\n        return false;\n      });\n\n      Object.keys(hashesMap).forEach(function (hash) {\n        var asset = hashesMap[hash];\n\n        // Return if not in sectionAssets or in changed or moved array\n        if (sectionAssets.indexOf(asset) === -1 || changed.indexOf(asset) !== -1 || moved.indexOf(asset) !== -1) return;\n\n        var lastAsset = lastMap[hash];\n\n        if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {\n          moved.push([lastAsset, asset]);\n        } else {\n          changed.push(asset);\n        }\n      });\n\n      logGroup('Changed assets: ' + section, changed);\n      logGroup('Moved assets: ' + section, moved);\n\n      var movedResponses = Promise.all(moved.map(function (pair) {\n        return lastCache.match(pair[0]).then(function (response) {\n          return [pair[1], response];\n        });\n      }));\n\n      return caches.open(CACHE_NAME).then(function (cache) {\n        var move = movedResponses.then(function (responses) {\n          return Promise.all(responses.map(function (pair) {\n            return cache.put(pair[0], pair[1]);\n          }));\n        });\n\n        return Promise.all([move, addAllNormalized(cache, changed, {\n          bust: params.version,\n          request: prefetchRequest,\n          failAll: section === 'main',\n          deleteFirst: section !== 'main'\n        })]);\n      });\n    });\n  }\n\n  function deleteObsolete() {\n    return caches.keys().then(function (keys) {\n      var all = keys.map(function (key) {\n        if (key.indexOf(CACHE_PREFIX) !== 0 || key.indexOf(CACHE_NAME) === 0) return;\n\n        console.log('[SW]:', 'Delete cache:', key);\n        return caches['delete'](key);\n      });\n\n      return Promise.all(all);\n    });\n  }\n\n  function getLastCache() {\n    return caches.keys().then(function (keys) {\n      var index = keys.length;\n      var key = undefined;\n\n      while (index--) {\n        key = keys[index];\n\n        if (key.indexOf(CACHE_PREFIX) === 0) {\n          break;\n        }\n      }\n\n      if (!key) return;\n\n      var cache = undefined;\n\n      return caches.open(key).then(function (_cache) {\n        cache = _cache;\n        return _cache.match(new URL(STORED_DATA_KEY, location).toString());\n      }).then(function (response) {\n        if (!response) return;\n\n        return Promise.all([cache, cache.keys(), response.json()]);\n      });\n    });\n  }\n\n  function storeCacheData() {\n    return caches.open(CACHE_NAME).then(function (cache) {\n      var data = new Response(JSON.stringify({\n        version: params.version,\n        hashmap: hashesMap\n      }));\n\n      return cache.put(new URL(STORED_DATA_KEY, location).toString(), data);\n    });\n  }\n\n  self.addEventListener('fetch', function (event) {\n    // Handle only GET requests\n    if (event.request.method !== 'GET') {\n      return;\n    }\n\n    // This prevents some weird issue with Chrome DevTools and 'only-if-cached'\n    // Fixes issue #385, also ref to:\n    // - https://github.com/paulirish/caltrainschedule.io/issues/49\n    // - https://bugs.chromium.org/p/chromium/issues/detail?id=823392\n    if (event.request.cache === 'only-if-cached' && event.request.mode !== 'same-origin') {\n      return;\n    }\n\n    var url = new URL(event.request.url);\n    url.hash = '';\n\n    var urlString = url.toString();\n\n    // Not external, so search part of the URL should be stripped,\n    // if it's external URL, the search part should be kept\n    if (externals.indexOf(urlString) === -1) {\n      url.search = '';\n      urlString = url.toString();\n    }\n\n    var assetMatches = allAssets.indexOf(urlString) !== -1;\n    var cacheUrl = urlString;\n\n    if (!assetMatches) {\n      var cacheRewrite = matchCacheMap(event.request);\n\n      if (cacheRewrite) {\n        cacheUrl = cacheRewrite;\n        assetMatches = true;\n      }\n    }\n\n    if (!assetMatches) {\n      // Use request.mode === 'navigate' instead of isNavigateRequest\n      // because everything what supports navigationPreload supports\n      // 'navigate' request.mode\n      if (event.request.mode === 'navigate') {\n        // Requesting with fetchWithPreload().\n        // Preload is used only if navigationPreload is enabled and\n        // navigationPreload mapping is not used.\n        if (navigationPreload === true) {\n          event.respondWith(fetchWithPreload(event));\n          return;\n        }\n      }\n\n      // Something else, positive, but not `true`\n      if (navigationPreload) {\n        var preloadedResponse = retrivePreloadedResponse(event);\n\n        if (preloadedResponse) {\n          event.respondWith(preloadedResponse);\n          return;\n        }\n      }\n\n      // Logic exists here if no cache match\n      return;\n    }\n\n    // Cache handling/storing/fetching starts here\n    var resource = undefined;\n\n    if (responseStrategy === 'network-first') {\n      resource = networkFirstResponse(event, urlString, cacheUrl);\n    }\n    // 'cache-first' otherwise\n    // (responseStrategy has been validated before)\n    else {\n        resource = cacheFirstResponse(event, urlString, cacheUrl);\n      }\n\n    event.respondWith(resource);\n  });\n\n  self.addEventListener('message', function (e) {\n    var data = e.data;\n    if (!data) return;\n\n    switch (data.action) {\n      case 'skipWaiting':\n        {\n          if (self.skipWaiting) self.skipWaiting();\n        }break;\n    }\n  });\n\n  function cacheFirstResponse(event, urlString, cacheUrl) {\n    handleNavigationPreload(event);\n\n    return cachesMatch(cacheUrl, CACHE_NAME).then(function (response) {\n      if (response) {\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + cacheUrl + '](' + urlString + ') from cache');\n        }\n\n        return response;\n      }\n\n      // Load and cache known assets\n      var fetching = fetch(event.request).then(function (response) {\n        if (!response.ok) {\n          if (DEBUG) {\n            console.log('[SW]:', 'URL [' + urlString + '] wrong response: [' + response.status + '] ' + response.type);\n          }\n\n          return response;\n        }\n\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + urlString + '] from network');\n        }\n\n        if (cacheUrl === urlString) {\n          (function () {\n            var responseClone = response.clone();\n            var storing = caches.open(CACHE_NAME).then(function (cache) {\n              return cache.put(urlString, responseClone);\n            }).then(function () {\n              console.log('[SW]:', 'Cache asset: ' + urlString);\n            });\n\n            event.waitUntil(storing);\n          })();\n        }\n\n        return response;\n      });\n\n      return fetching;\n    });\n  }\n\n  function networkFirstResponse(event, urlString, cacheUrl) {\n    return fetchWithPreload(event).then(function (response) {\n      if (response.ok) {\n        if (DEBUG) {\n          console.log('[SW]:', 'URL [' + urlString + '] from network');\n        }\n\n        return response;\n      }\n\n      // Throw to reach the code in the catch below\n      throw response;\n    })\n    // This needs to be in a catch() and not just in the then() above\n    // cause if your network is down, the fetch() will throw\n    ['catch'](function (erroredResponse) {\n      if (DEBUG) {\n        console.log('[SW]:', 'URL [' + urlString + '] from cache if possible');\n      }\n\n      return cachesMatch(cacheUrl, CACHE_NAME).then(function (response) {\n        if (response) {\n          return response;\n        }\n\n        if (erroredResponse instanceof Response) {\n          return erroredResponse;\n        }\n\n        // Not a response at this point, some other error\n        throw erroredResponse;\n        // return Response.error();\n      });\n    });\n  }\n\n  function handleNavigationPreload(event) {\n    if (navigationPreload && typeof navigationPreload.map === 'function' &&\n    // Use request.mode === 'navigate' instead of isNavigateRequest\n    // because everything what supports navigationPreload supports\n    // 'navigate' request.mode\n    event.preloadResponse && event.request.mode === 'navigate') {\n      var mapped = navigationPreload.map(new URL(event.request.url), event.request);\n\n      if (mapped) {\n        storePreloadedResponse(mapped, event);\n      }\n    }\n  }\n\n  // Temporary in-memory store for faster access\n  var navigationPreloadStore = new Map();\n\n  function storePreloadedResponse(_url, event) {\n    var url = new URL(_url, location);\n    var preloadResponsePromise = event.preloadResponse;\n\n    navigationPreloadStore.set(preloadResponsePromise, {\n      url: url,\n      response: preloadResponsePromise\n    });\n\n    var isSamePreload = function isSamePreload() {\n      return navigationPreloadStore.has(preloadResponsePromise);\n    };\n\n    var storing = preloadResponsePromise.then(function (res) {\n      // Return if preload isn't enabled or hasn't happened\n      if (!res) return;\n\n      // If navigationPreloadStore already consumed\n      // or navigationPreloadStore already contains another preload,\n      // then do not store anything and return\n      if (!isSamePreload()) {\n        return;\n      }\n\n      var clone = res.clone();\n\n      // Storing the preload response for later consume (hasn't yet been consumed)\n      return caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n        if (!isSamePreload()) return;\n\n        return cache.put(url, clone).then(function () {\n          if (!isSamePreload()) {\n            return caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n              return cache['delete'](url);\n            });\n          }\n        });\n      });\n    });\n\n    event.waitUntil(storing);\n  }\n\n  function retriveInMemoryPreloadedResponse(url) {\n    if (!navigationPreloadStore) {\n      return;\n    }\n\n    var foundResponse = undefined;\n    var foundKey = undefined;\n\n    navigationPreloadStore.forEach(function (store, key) {\n      if (store.url.href === url.href) {\n        foundResponse = store.response;\n        foundKey = key;\n      }\n    });\n\n    if (foundResponse) {\n      navigationPreloadStore['delete'](foundKey);\n      return foundResponse;\n    }\n  }\n\n  function retrivePreloadedResponse(event) {\n    var url = new URL(event.request.url);\n\n    if (self.registration.navigationPreload && navigationPreload && navigationPreload.test && navigationPreload.test(url, event.request)) {} else {\n      return;\n    }\n\n    var fromMemory = retriveInMemoryPreloadedResponse(url);\n    var request = event.request;\n\n    if (fromMemory) {\n      event.waitUntil(caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n        return cache['delete'](request);\n      }));\n\n      return fromMemory;\n    }\n\n    return cachesMatch(request, PRELOAD_CACHE_NAME).then(function (response) {\n      if (response) {\n        event.waitUntil(caches.open(PRELOAD_CACHE_NAME).then(function (cache) {\n          return cache['delete'](request);\n        }));\n      }\n\n      return response || fetch(event.request);\n    });\n  }\n\n  function mapAssets() {\n    Object.keys(assets).forEach(function (key) {\n      assets[key] = assets[key].map(function (path) {\n        var url = new URL(path, location);\n\n        url.hash = '';\n\n        if (externals.indexOf(path) === -1) {\n          url.search = '';\n        }\n\n        return url.toString();\n      });\n    });\n\n    hashesMap = Object.keys(hashesMap).reduce(function (result, hash) {\n      var url = new URL(hashesMap[hash], location);\n      url.search = '';\n      url.hash = '';\n\n      result[hash] = url.toString();\n      return result;\n    }, {});\n\n    externals = externals.map(function (path) {\n      var url = new URL(path, location);\n      url.hash = '';\n\n      return url.toString();\n    });\n  }\n\n  function addAllNormalized(cache, requests, options) {\n    requests = requests.slice();\n\n    var bustValue = options.bust;\n    var failAll = options.failAll !== false;\n    var deleteFirst = options.deleteFirst === true;\n    var requestInit = options.request || {\n      credentials: 'omit',\n      mode: 'cors'\n    };\n\n    var deleting = Promise.resolve();\n\n    if (deleteFirst) {\n      deleting = Promise.all(requests.map(function (request) {\n        return cache['delete'](request)['catch'](function () {});\n      }));\n    }\n\n    return Promise.all(requests.map(function (request) {\n      if (bustValue) {\n        request = applyCacheBust(request, bustValue);\n      }\n\n      return fetch(request, requestInit).then(fixRedirectedResponse).then(function (response) {\n        if (!response.ok) {\n          return { error: true };\n        }\n\n        return { response: response };\n      }, function () {\n        return { error: true };\n      });\n    })).then(function (responses) {\n      if (failAll && responses.some(function (data) {\n        return data.error;\n      })) {\n        return Promise.reject(new Error('Wrong response status'));\n      }\n\n      if (!failAll) {\n        responses = responses.filter(function (data, i) {\n          if (!data.error) {\n            return true;\n          }\n\n          requests.splice(i, 1);\n          return false;\n        });\n      }\n\n      return deleting.then(function () {\n        var addAll = responses.map(function (_ref, i) {\n          var response = _ref.response;\n\n          return cache.put(requests[i], response);\n        });\n\n        return Promise.all(addAll);\n      });\n    });\n  }\n\n  function matchCacheMap(request) {\n    var urlString = request.url;\n    var url = new URL(urlString);\n\n    var requestType = undefined;\n\n    if (isNavigateRequest(request)) {\n      requestType = 'navigate';\n    } else if (url.origin === location.origin) {\n      requestType = 'same-origin';\n    } else {\n      requestType = 'cross-origin';\n    }\n\n    for (var i = 0; i < cacheMaps.length; i++) {\n      var map = cacheMaps[i];\n\n      if (!map) continue;\n      if (map.requestTypes && map.requestTypes.indexOf(requestType) === -1) {\n        continue;\n      }\n\n      var newString = undefined;\n\n      if (typeof map.match === 'function') {\n        newString = map.match(url, request);\n      } else {\n        newString = urlString.replace(map.match, map.to);\n      }\n\n      if (newString && newString !== urlString) {\n        return newString;\n      }\n    }\n  }\n\n  function fetchWithPreload(event) {\n    if (!event.preloadResponse || navigationPreload !== true) {\n      return fetch(event.request);\n    }\n\n    return event.preloadResponse.then(function (response) {\n      return response || fetch(event.request);\n    });\n  }\n}\n\nfunction cachesMatch(request, cacheName) {\n  return caches.match(request, {\n    cacheName: cacheName\n  }).then(function (response) {\n    if (isNotRedirectedResponse(response)) {\n      return response;\n    }\n\n    // Fix already cached redirected responses\n    return fixRedirectedResponse(response).then(function (fixedResponse) {\n      return caches.open(cacheName).then(function (cache) {\n        return cache.put(request, fixedResponse);\n      }).then(function () {\n        return fixedResponse;\n      });\n    });\n  })\n  // Return void if error happened (cache not found)\n  ['catch'](function () {});\n}\n\nfunction applyCacheBust(asset, key) {\n  var hasQuery = asset.indexOf('?') !== -1;\n  return asset + (hasQuery ? '&' : '?') + '__uncache=' + encodeURIComponent(key);\n}\n\nfunction isNavigateRequest(request) {\n  return request.mode === 'navigate' || request.headers.get('Upgrade-Insecure-Requests') || (request.headers.get('Accept') || '').indexOf('text/html') !== -1;\n}\n\nfunction isNotRedirectedResponse(response) {\n  return !response || !response.redirected || !response.ok || response.type === 'opaqueredirect';\n}\n\n// Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85\nfunction fixRedirectedResponse(response) {\n  if (isNotRedirectedResponse(response)) {\n    return Promise.resolve(response);\n  }\n\n  var body = 'body' in response ? Promise.resolve(response.body) : response.blob();\n\n  return body.then(function (data) {\n    return new Response(data, {\n      headers: response.headers,\n      status: response.status\n    });\n  });\n}\n\nfunction copyObject(original) {\n  return Object.keys(original).reduce(function (result, key) {\n    result[key] = original[key];\n    return result;\n  }, {});\n}\n\nfunction logGroup(title, assets) {\n  console.groupCollapsed('[SW]:', title);\n\n  assets.forEach(function (asset) {\n    console.log('Asset:', asset);\n  });\n\n  console.groupEnd();\n}\n        WebpackServiceWorker(__wpo, {\nloaders: {},\ncacheMaps: [\n      {\n      match: function(url) {\n          if (url.pathname === location.pathname) {\n            return;\n          }\n\n          return new URL(\"/Chatnoir/\", location);\n        },\n      to: null,\n      requestTypes: [\"navigate\"],\n    }\n    ],\nnavigationPreload: false,\n});\n        module.exports = __webpack_require__(/*! ./sw-img.js */ \"./src/js/sw-img.js\")\n      \n\n//# sourceURL=webpack:///./src/js/sw-img.js?./node_modules/offline-plugin/lib/misc/sw-loader.js?json=%257B%2522data_var_name%2522%253A%2522__wpo%2522%252C%2522cacheMaps%2522%253A%255B%257B%2522match%2522%253A%2522function%2528url%2529%2520%257B%255Cn%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520if%2520%2528url.pathname%2520%253D%253D%253D%2520location.pathname%2529%2520%257B%255Cn%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520return%253B%255Cn%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257D%255Cn%255Cn%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520return%2520new%2520URL%2528%255C%2522/Chatnoir/%255C%2522%252C%2520location%2529%253B%255Cn%2520%2520%2520%2520%2520%2520%2520%2520%257D%2522%252C%2522to%2522%253Anull%252C%2522requestTypes%2522%253A%255B%2522navigate%2522%255D%257D%255D%252C%2522navigationPreload%2522%253A%2522false%2522%257D");

/***/ }),

/***/ "./node_modules/workbox-core/_private/WorkboxError.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/workbox-core/_private/WorkboxError.mjs ***!
  \*************************************************************/
/*! exports provided: WorkboxError */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WorkboxError\", function() { return WorkboxError; });\n/* harmony import */ var _models_messages_messageGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/messages/messageGenerator.mjs */ \"./node_modules/workbox-core/models/messages/messageGenerator.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = Object(_models_messages_messageGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__[\"messageGenerator\"])(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/WorkboxError.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/assert.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/workbox-core/_private/assert.mjs ***!
  \*******************************************************/
/*! exports provided: assert */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assert\", function() { return finalAssertExports; });\n/* harmony import */ var _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n    {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n    {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n    {moduleName, className, funcName,\n      paramName, isReturnValueProblem}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName, isReturnValueProblem});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n    {moduleName, className, funcName, paramName}) => {\n  const error = new _private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports =  false ? undefined : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSWEnv,\n  isType,\n  isArrayOfClass,\n};\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/assert.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/cacheNames.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/workbox-core/_private/cacheNames.mjs ***!
  \***********************************************************/
/*! exports provided: cacheNames */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheNames\", function() { return cacheNames; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: self.registration.scope,\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n      .filter((value) => value.length > 0)\n      .join('-');\n};\n\nconst cacheNames = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  },\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/cacheNames.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/cacheWrapper.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/workbox-core/_private/cacheWrapper.mjs ***!
  \*************************************************************/
/*! exports provided: cacheWrapper */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheWrapper\", function() { return cacheWrapper; });\n/* harmony import */ var _WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _assert_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var _getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getFriendlyURL.mjs */ \"./node_modules/workbox-core/_private/getFriendlyURL.mjs\");\n/* harmony import */ var _logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _executeQuotaErrorCallbacks_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./executeQuotaErrorCallbacks.mjs */ \"./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.mjs\");\n/* harmony import */ var _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../models/pluginEvents.mjs */ \"./node_modules/workbox-core/models/pluginEvents.mjs\");\n/* harmony import */ var _utils_pluginUtils_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/pluginUtils.mjs */ \"./node_modules/workbox-core/utils/pluginUtils.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (true) {\n    if (request.method && request.method !== 'GET') {\n      throw new _WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('attempt-to-cache-non-get-request', {\n        url: Object(_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getFriendlyURL\"])(request.url),\n        method: request.method,\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'write'});\n\n  if (!response) {\n    if (true) {\n      _logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].error(`Cannot cache non-existent response for ` +\n        `'${Object(_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getFriendlyURL\"])(effectiveRequest.url)}'.`);\n    }\n\n    throw new _WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('cache-put-with-no-response', {\n      url: Object(_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getFriendlyURL\"])(effectiveRequest.url),\n    });\n  }\n\n  let responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest,\n  });\n\n  if (!responseToCache) {\n    if (true) {\n      _logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].debug(`Response '${Object(_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getFriendlyURL\"])(effectiveRequest.url)}' will ` +\n      `not be cached.`, responseToCache);\n    }\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = _utils_pluginUtils_mjs__WEBPACK_IMPORTED_MODULE_6__[\"pluginUtils\"].filter(\n      plugins, _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\n      null;\n\n  if (true) {\n    _logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${Object(_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getFriendlyURL\"])(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await Object(_executeQuotaErrorCallbacks_mjs__WEBPACK_IMPORTED_MODULE_4__[\"executeQuotaErrorCallbacks\"])();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'read'});\n\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (true) {\n    if (cachedResponse) {\n      _logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      _logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            event,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n          });\n      if (true) {\n        if (cachedResponse) {\n          _assert_mjs__WEBPACK_IMPORTED_MODULE_1__[\"assert\"].isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (true) {\n        if (responseToCache) {\n          _assert_mjs__WEBPACK_IMPORTED_MODULE_1__[\"assert\"].isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (true) {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          _logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          _logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\n  const cacheKeyWillBeUsedPlugins = _utils_pluginUtils_mjs__WEBPACK_IMPORTED_MODULE_6__[\"pluginUtils\"].filter(\n      plugins, _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_KEY_WILL_BE_USED);\n\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_KEY_WILL_BE_USED].call(\n        plugin, {mode, request: effectiveRequest});\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (true) {\n      _assert_mjs__WEBPACK_IMPORTED_MODULE_1__[\"assert\"].isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginEvents\"].CACHE_KEY_WILL_BE_USED,\n        isReturnValueProblem: true,\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n\nconst cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/cacheWrapper.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.mjs ***!
  \***************************************************************************/
/*! exports provided: executeQuotaErrorCallbacks */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"executeQuotaErrorCallbacks\", function() { return executeQuotaErrorCallbacks; });\n/* harmony import */ var _private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _models_quotaErrorCallbacks_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/quotaErrorCallbacks.mjs */ \"./node_modules/workbox-core/models/quotaErrorCallbacks.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (true) {\n    _private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(`About to run ${_models_quotaErrorCallbacks_mjs__WEBPACK_IMPORTED_MODULE_1__[\"quotaErrorCallbacks\"].size} ` +\n        `callbacks to clean up caches.`);\n  }\n\n  for (const callback of _models_quotaErrorCallbacks_mjs__WEBPACK_IMPORTED_MODULE_1__[\"quotaErrorCallbacks\"]) {\n    await callback();\n    if (true) {\n      _private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(callback, 'is complete.');\n    }\n  }\n\n  if (true) {\n    _private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log('Finished running callbacks.');\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/fetchWrapper.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/workbox-core/_private/fetchWrapper.mjs ***!
  \*************************************************************/
/*! exports provided: fetchWrapper */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetchWrapper\", function() { return fetchWrapper; });\n/* harmony import */ var _WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _assert_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var _private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_private/getFriendlyURL.mjs */ \"./node_modules/workbox-core/_private/getFriendlyURL.mjs\");\n/* harmony import */ var _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../models/pluginEvents.mjs */ \"./node_modules/workbox-core/models/pluginEvents.mjs\");\n/* harmony import */ var _utils_pluginUtils_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/pluginUtils.mjs */ \"./node_modules/workbox-core/utils/pluginUtils.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (true) {\n        _logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(`Using a preloaded navigation response for ` +\n          `'${Object(_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__[\"getFriendlyURL\"])(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (true) {\n    _assert_mjs__WEBPACK_IMPORTED_MODULE_2__[\"assert\"].isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = _utils_pluginUtils_mjs__WEBPACK_IMPORTED_MODULE_5__[\"pluginUtils\"].filter(\n      plugins, _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (true) {\n          if (request) {\n            _assert_mjs__WEBPACK_IMPORTED_MODULE_2__[\"assert\"].isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new _WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"WorkboxError\"]('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (true) {\n      _logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].debug(`Network request for `+\n      `'${Object(_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__[\"getFriendlyURL\"])(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (true) {\n          if (fetchResponse) {\n            _assert_mjs__WEBPACK_IMPORTED_MODULE_2__[\"assert\"].isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: _models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (true) {\n      _logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].error(`Network request for `+\n      `'${Object(_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__[\"getFriendlyURL\"])(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[_models_pluginEvents_mjs__WEBPACK_IMPORTED_MODULE_4__[\"pluginEvents\"].FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/fetchWrapper.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/getFriendlyURL.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/workbox-core/_private/getFriendlyURL.mjs ***!
  \***************************************************************/
/*! exports provided: getFriendlyURL */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFriendlyURL\", function() { return getFriendlyURL; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/getFriendlyURL.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/logger.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/workbox-core/_private/logger.mjs ***!
  \*******************************************************/
/*! exports provided: logger */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logger\", function() { return logger; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\nconst logger =  false ? undefined : (() => {\n  let inGroup = false;\n\n  const methodToColorMap = {\n    debug: `#7f8c8d`, // Gray\n    log: `#2ecc71`, // Green\n    warn: `#f39c12`, // Yellow\n    error: `#c0392b`, // Red\n    groupCollapsed: `#3498db`, // Blue\n    groupEnd: null, // No colored prefix on groupEnd\n  };\n\n  const print = function(method, args) {\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n\n    const styles = [\n      `background: ${methodToColorMap[method]}`,\n      `border-radius: 0.5em`,\n      `color: white`,\n      `font-weight: bold`,\n      `padding: 2px 0.5em`,\n    ];\n\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    console[method](...logPrefix, ...args);\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  const api = {};\n  for (const method of Object.keys(methodToColorMap)) {\n    api[method] = (...args) => {\n      print(method, args);\n    };\n  }\n\n  return api;\n})();\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_private/logger.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/_version.mjs":
/*!************************************************!*\
  !*** ./node_modules/workbox-core/_version.mjs ***!
  \************************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\ntry{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line\n\n//# sourceURL=webpack:///./node_modules/workbox-core/_version.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/models/messages/messageGenerator.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/workbox-core/models/messages/messageGenerator.mjs ***!
  \************************************************************************/
/*! exports provided: messageGenerator */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"messageGenerator\", function() { return messageGenerator; });\n/* harmony import */ var _messages_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.mjs */ \"./node_modules/workbox-core/models/messages/messages.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = _messages_mjs__WEBPACK_IMPORTED_MODULE_0__[\"messages\"][code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nconst messageGenerator = ( false) ?\n    undefined : generatorFunction;\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/models/messages/messageGenerator.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/models/messages/messages.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/workbox-core/models/messages/messages.mjs ***!
  \****************************************************************/
/*! exports provided: messages */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"messages\", function() { return messages; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\nconst messages = {\n  'invalid-value': ({paramName, validValueDescription, value}) => {\n    if (!paramName || !validValueDescription) {\n      throw new Error(`Unexpected input to 'invalid-value' error.`);\n    }\n    return `The '${paramName}' parameter was given a value with an ` +\n      `unexpected value. ${validValueDescription} Received a value of ` +\n      `${JSON.stringify(value)}.`;\n  },\n\n  'not-in-sw': ({moduleName}) => {\n    if (!moduleName) {\n      throw new Error(`Unexpected input to 'not-in-sw' error.`);\n    }\n    return `The '${moduleName}' must be used in a service worker.`;\n  },\n\n  'not-an-array': ({moduleName, className, funcName, paramName}) => {\n    if (!moduleName || !className || !funcName || !paramName) {\n      throw new Error(`Unexpected input to 'not-an-array' error.`);\n    }\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className}.${funcName}()' must be an array.`;\n  },\n\n  'incorrect-type': ({expectedType, paramName, moduleName, className,\n    funcName}) => {\n    if (!expectedType || !paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-type' error.`);\n    }\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className ? (className + '.') : ''}` +\n      `${funcName}()' must be of type ${expectedType}.`;\n  },\n\n  'incorrect-class': ({expectedClass, paramName, moduleName, className,\n    funcName, isReturnValueProblem}) => {\n    if (!expectedClass || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-class' error.`);\n    }\n\n    if (isReturnValueProblem) {\n      return `The return value from ` +\n        `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\n        `must be an instance of class ${expectedClass.name}.`;\n    }\n\n    return `The parameter '${paramName}' passed into ` +\n      `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\n      `must be an instance of class ${expectedClass.name}.`;\n  },\n\n  'missing-a-method': ({expectedMethod, paramName, moduleName, className,\n    funcName}) => {\n    if (!expectedMethod || !paramName || !moduleName || !className\n        || !funcName) {\n      throw new Error(`Unexpected input to 'missing-a-method' error.`);\n    }\n    return `${moduleName}.${className}.${funcName}() expected the ` +\n      `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n  },\n\n  'add-to-cache-list-unexpected-type': ({entry}) => {\n    return `An unexpected entry was passed to ` +\n    `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +\n    `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +\n    `strings with one or more characters, objects with a url property or ` +\n    `Request objects.`;\n  },\n\n  'add-to-cache-list-conflicting-entries': ({firstEntry, secondEntry}) => {\n    if (!firstEntry || !secondEntry) {\n      throw new Error(`Unexpected input to ` +\n        `'add-to-cache-list-duplicate-entries' error.`);\n    }\n\n    return `Two of the entries passed to ` +\n      `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\n      `${firstEntry._entryId} but different revision details. Workbox is ` +\n      `is unable to cache and version the asset correctly. Please remove one ` +\n      `of the entries.`;\n  },\n\n  'plugin-error-request-will-fetch': ({thrownError}) => {\n    if (!thrownError) {\n      throw new Error(`Unexpected input to ` +\n        `'plugin-error-request-will-fetch', error.`);\n    }\n\n    return `An error was thrown by a plugins 'requestWillFetch()' method. ` +\n      `The thrown error message was: '${thrownError.message}'.`;\n  },\n\n  'invalid-cache-name': ({cacheNameId, value}) => {\n    if (!cacheNameId) {\n      throw new Error(\n          `Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n    }\n\n    return `You must provide a name containing at least one character for ` +\n      `setCacheDeatils({${cacheNameId}: '...'}). Received a value of ` +\n      `'${JSON.stringify(value)}'`;\n  },\n\n  'unregister-route-but-not-found-with-method': ({method}) => {\n    if (!method) {\n      throw new Error(`Unexpected input to ` +\n        `'unregister-route-but-not-found-with-method' error.`);\n    }\n\n    return `The route you're trying to unregister was not  previously ` +\n      `registered for the method type '${method}'.`;\n  },\n\n  'unregister-route-route-not-registered': () => {\n    return `The route you're trying to unregister was not previously ` +\n      `registered.`;\n  },\n\n  'queue-replay-failed': ({name}) => {\n    return `Replaying the background sync queue '${name}' failed.`;\n  },\n\n  'duplicate-queue-name': ({name}) => {\n    return `The Queue name '${name}' is already being used. ` +\n        `All instances of backgroundSync.Queue must be given unique names.`;\n  },\n\n  'expired-test-without-max-age': ({methodName, paramName}) => {\n    return `The '${methodName}()' method can only be used when the ` +\n      `'${paramName}' is used in the constructor.`;\n  },\n\n  'unsupported-route-type': ({moduleName, className, funcName, paramName}) => {\n    return `The supplied '${paramName}' parameter was an unsupported type. ` +\n      `Please check the docs for ${moduleName}.${className}.${funcName} for ` +\n      `valid input types.`;\n  },\n\n  'not-array-of-class': ({value, expectedClass,\n    moduleName, className, funcName, paramName}) => {\n    return `The supplied '${paramName}' parameter must be an array of ` +\n      `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +\n      `Please check the call to ${moduleName}.${className}.${funcName}() ` +\n      `to fix the issue.`;\n  },\n\n  'max-entries-or-age-required': ({moduleName, className, funcName}) => {\n    return `You must define either config.maxEntries or config.maxAgeSeconds` +\n      `in ${moduleName}.${className}.${funcName}`;\n  },\n\n  'statuses-or-headers-required': ({moduleName, className, funcName}) => {\n    return `You must define either config.statuses or config.headers` +\n      `in ${moduleName}.${className}.${funcName}`;\n  },\n\n  'invalid-string': ({moduleName, className, funcName, paramName}) => {\n    if (!paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'invalid-string' error.`);\n    }\n    return `When using strings, the '${paramName}' parameter must start with ` +\n      `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +\n      `Please see the docs for ${moduleName}.${funcName}() for ` +\n      `more info.`;\n  },\n\n  'channel-name-required': () => {\n    return `You must provide a channelName to construct a ` +\n    `BroadcastCacheUpdate instance.`;\n  },\n\n  'invalid-responses-are-same-args': () => {\n    return `The arguments passed into responsesAreSame() appear to be ` +\n      `invalid. Please ensure valid Responses are used.`;\n  },\n\n  'expire-custom-caches-only': () => {\n    return `You must provide a 'cacheName' property when using the ` +\n      `expiration plugin with a runtime caching strategy.`;\n  },\n\n  'unit-must-be-bytes': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n    }\n    return `The 'unit' portion of the Range header must be set to 'bytes'. ` +\n      `The Range header provided was \"${normalizedRangeHeader}\"`;\n  },\n\n  'single-range-only': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'single-range-only' error.`);\n    }\n    return `Multiple ranges are not supported. Please use a  single start ` +\n      `value, and optional end value. The Range header provided was ` +\n      `\"${normalizedRangeHeader}\"`;\n  },\n\n  'invalid-range-values': ({normalizedRangeHeader}) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n    }\n    return `The Range header is missing both start and end values. At least ` +\n      `one of those values is needed. The Range header provided was ` +\n      `\"${normalizedRangeHeader}\"`;\n  },\n\n  'no-range-header': () => {\n    return `No Range header was found in the Request provided.`;\n  },\n\n  'range-not-satisfiable': ({size, start, end}) => {\n    return `The start (${start}) and end (${end}) values in the Range are ` +\n      `not satisfiable by the cached response, which is ${size} bytes.`;\n  },\n\n  'attempt-to-cache-non-get-request': ({url, method}) => {\n    return `Unable to cache '${url}' because it is a '${method}' request and ` +\n      `only 'GET' requests can be cached.`;\n  },\n\n  'cache-put-with-no-response': ({url}) => {\n    return `There was an attempt to cache '${url}' but the response was not ` +\n      `defined.`;\n  },\n\n  'no-response': ({url, error}) => {\n    let message = `The strategy could not generate a response for '${url}'.`;\n    if (error) {\n      message += ` The underlying error is ${error}.`;\n    }\n    return message;\n  },\n\n  'bad-precaching-response': ({url, status}) => {\n    return `The precaching request for '${url}' failed with an HTTP ` +\n      `status of ${status}.`;\n  },\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/models/messages/messages.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/models/pluginEvents.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/workbox-core/models/pluginEvents.mjs ***!
  \***********************************************************/
/*! exports provided: pluginEvents */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pluginEvents\", function() { return pluginEvents; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\nconst pluginEvents = {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/models/pluginEvents.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/models/quotaErrorCallbacks.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/workbox-core/models/quotaErrorCallbacks.mjs ***!
  \******************************************************************/
/*! exports provided: quotaErrorCallbacks */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"quotaErrorCallbacks\", function() { return quotaErrorCallbacks; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n// Callbacks to be executed whenever there's a quota error.\nconst quotaErrorCallbacks = new Set();\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/models/quotaErrorCallbacks.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/utils/pluginUtils.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/workbox-core/utils/pluginUtils.mjs ***!
  \*********************************************************/
/*! exports provided: pluginUtils */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pluginUtils\", function() { return pluginUtils; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-core/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\nconst pluginUtils = {\n  filter: (plugins, callbackName) => {\n    return plugins.filter((plugin) => callbackName in plugin);\n  },\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-core/utils/pluginUtils.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/NavigationRoute.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-routing/NavigationRoute.mjs ***!
  \**********************************************************/
/*! exports provided: NavigationRoute */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationRoute\", function() { return NavigationRoute; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _Route_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route.mjs */ \"./node_modules/workbox-routing/Route.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * NavigationRoute makes it easy to create a [Route]{@link\n * workbox.routing.Route} that matches for browser\n * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n *\n * It will only match incoming Requests whose\n * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\n * is set to `navigate`.\n *\n * You can optionally only apply this route to a subset of navigation requests\n * by using one or both of the `blacklist` and `whitelist` parameters.\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass NavigationRoute extends _Route_mjs__WEBPACK_IMPORTED_MODULE_2__[\"Route\"] {\n  /**\n   * If both `blacklist` and `whiltelist` are provided, the `blacklist` will\n   * take precedence and the request will not match this route.\n   *\n   * The regular expressions in `whitelist` and `blacklist`\n   * are matched against the concatenated\n   * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n   * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n   * portions of the requested URL.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {Object} options\n   * @param {Array<RegExp>} [options.blacklist] If any of these patterns match,\n   * the route will not handle the request (even if a whitelist RegExp matches).\n   * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n   * match the URL's pathname and search parameter, the route will handle the\n   * request (assuming the blacklist doesn't match).\n   */\n  constructor(handler, {whitelist = [/./], blacklist = []} = {}) {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isArrayOfClass(whitelist, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'NavigationRoute',\n        funcName: 'constructor',\n        paramName: 'options.whitelist',\n      });\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isArrayOfClass(blacklist, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'NavigationRoute',\n        funcName: 'constructor',\n        paramName: 'options.blacklist',\n      });\n    }\n\n    super((options) => this._match(options), handler);\n\n    this._whitelist = whitelist;\n    this._blacklist = blacklist;\n  }\n\n  /**\n   * Routes match handler.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request\n   * @return {boolean}\n   *\n   * @private\n   */\n  _match({url, request}) {\n    if (request.mode !== 'navigate') {\n      return false;\n    }\n\n    const pathnameAndSearch = url.pathname + url.search;\n\n    for (const regExp of this._blacklist) {\n      if (regExp.test(pathnameAndSearch)) {\n        if (true) {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(`The navigation route is not being used, since the ` +\n              `URL matches this blacklist pattern: ${regExp}`);\n        }\n        return false;\n      }\n    }\n\n    if (this._whitelist.some((regExp) => regExp.test(pathnameAndSearch))) {\n      if (true) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].debug(`The navigation route is being used.`);\n      }\n      return true;\n    }\n\n    if (true) {\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(`The navigation route is not being used, since the URL ` +\n          `being navigated to doesn't match the whitelist.`);\n    }\n    return false;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/NavigationRoute.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/RegExpRoute.mjs":
/*!******************************************************!*\
  !*** ./node_modules/workbox-routing/RegExpRoute.mjs ***!
  \******************************************************/
/*! exports provided: RegExpRoute */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RegExpRoute\", function() { return RegExpRoute; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _Route_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route.mjs */ \"./node_modules/workbox-routing/Route.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link workbox.routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass RegExpRoute extends _Route_mjs__WEBPACK_IMPORTED_MODULE_2__[\"Route\"] {\n  /**\n   * If the regulard expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * th ecaptured values will be passed to the\n   * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern',\n      });\n    }\n\n    const match = ({url}) => {\n      const result = regExp.exec(url.href);\n\n      // Return null immediately if there's no match.\n      if (!result) {\n        return null;\n      }\n\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\n        if (true) {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].debug(\n              `The regular expression '${regExp}' only partially matched ` +\n            `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\n            `handle cross-origin requests if they match the entire URL.`\n          );\n        }\n\n        return null;\n      }\n\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n\n    super(match, handler, method);\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/RegExpRoute.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/Route.mjs":
/*!************************************************!*\
  !*** ./node_modules/workbox-routing/Route.mjs ***!
  \************************************************/
/*! exports provided: Route */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Route\", function() { return Route; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var _utils_constants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/constants.mjs */ \"./node_modules/workbox-routing/utils/constants.mjs\");\n/* harmony import */ var _utils_normalizeHandler_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/normalizeHandler.mjs */ \"./node_modules/workbox-routing/utils/normalizeHandler.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox.routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {workbox.routing.Route~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler, method) {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isType(match, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'match',\n      });\n\n      if (method) {\n        workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isOneOf(method, _utils_constants_mjs__WEBPACK_IMPORTED_MODULE_1__[\"validMethods\"], {paramName: 'method'});\n      }\n    }\n\n    // These values are referenced directly by Router so cannot be\n    // altered by minifification.\n    this.handler = Object(_utils_normalizeHandler_mjs__WEBPACK_IMPORTED_MODULE_2__[\"normalizeHandler\"])(handler);\n    this.match = match;\n    this.method = method || _utils_constants_mjs__WEBPACK_IMPORTED_MODULE_1__[\"defaultMethod\"];\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/Route.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/Router.mjs":
/*!*************************************************!*\
  !*** ./node_modules/workbox-routing/Router.mjs ***!
  \*************************************************/
/*! exports provided: Router */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return Router; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.mjs */ \"./node_modules/workbox-core/_private/getFriendlyURL.mjs\");\n/* harmony import */ var _utils_normalizeHandler_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/normalizeHandler.mjs */ \"./node_modules/workbox-routing/utils/normalizeHandler.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n  }\n\n  /**\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    self.addEventListener('fetch', (event) => {\n      const {request} = event;\n      const responsePromise = this.handleRequest({request, event});\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    self.addEventListener('message', async (event) => {\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        const {payload} = event.data;\n\n        if (true) {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n\n        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({request});\n        }));\n\n        event.waitUntil(requestPromises);\n\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports && event.ports[0]) {\n          await requestPromises;\n          event.ports[0].postMessage(true);\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle (this is usually\n   *     from a fetch event, but it does not have to be).\n   * @param {FetchEvent} [options.event] The event that triggered the request,\n   *     if applicable.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest({request, event}) {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request',\n      });\n    }\n\n    const url = new URL(request.url, location);\n    if (!url.protocol.startsWith('http')) {\n      if (true) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].debug(\n            `Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n\n    let {params, route} = this.findMatchingRoute({url, request, event});\n    let handler = route && route.handler;\n\n    let debugMessages = [];\n    if (true) {\n      if (handler) {\n        debugMessages.push([\n          `Found a route to handle this request:`, route,\n        ]);\n\n        if (params) {\n          debugMessages.push([\n            `Passing the following params to the route's handler:`, params,\n          ]);\n        }\n      }\n    }\n\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    if (!handler && this._defaultHandler) {\n      if (true) {\n        debugMessages.push(`Failed to find a matching route. Falling ` +\n          `back to the default handler.`);\n\n        // This is used for debugging in logs in the case of an error.\n        route = '[Default Handler]';\n      }\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (true) {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].debug(`No route found for: ${Object(workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__[\"getFriendlyURL\"])(url)}`);\n      }\n      return;\n    }\n\n    if (true) {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].groupCollapsed(`Router is responding to: ${Object(workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__[\"getFriendlyURL\"])(url)}`);\n      debugMessages.forEach((msg) => {\n        if (Array.isArray(msg)) {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(...msg);\n        } else {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(msg);\n        }\n      });\n\n      // The Request and Response objects contains a great deal of information,\n      // hide it under a group in case developers want to see it.\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].groupCollapsed(`View request details here.`);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(request);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].groupEnd();\n\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].groupEnd();\n    }\n\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({url, request, event, params});\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise && this._catchHandler) {\n      responsePromise = responsePromise.catch((err) => {\n        if (true) {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].groupCollapsed(`Error thrown when responding to: ` +\n            ` ${Object(workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_3__[\"getFriendlyURL\"])(url)}. Falling back to Catch Handler.`);\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].error(`Error thrown by:`, route);\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].error(err);\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].groupEnd();\n        }\n        return this._catchHandler.handle({url, event, err});\n      });\n    }\n\n    return responsePromise;\n  }\n\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request The request to match.\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute({url, request, event}) {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(url, URL, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.url',\n      });\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.request',\n      });\n    }\n\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      let matchResult = route.match({url, request, event});\n      if (matchResult) {\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = matchResult;\n        } else if ((matchResult.constructor === Object &&\n            Object.keys(matchResult).length > 0)) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = matchResult;\n        }\n\n        // Return early if have a match.\n        return {route, params};\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setDefaultHandler(handler) {\n    this._defaultHandler = Object(_utils_normalizeHandler_mjs__WEBPACK_IMPORTED_MODULE_4__[\"normalizeHandler\"])(handler);\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = Object(_utils_normalizeHandler_mjs__WEBPACK_IMPORTED_MODULE_4__[\"normalizeHandler\"])(handler);\n  }\n\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler',\n      });\n\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method',\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_2__[\"WorkboxError\"](\n          'unregister-route-but-not-found-with-method', {\n            method: route.method,\n          }\n      );\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_2__[\"WorkboxError\"]('unregister-route-route-not-registered');\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/Router.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/_version.mjs":
/*!***************************************************!*\
  !*** ./node_modules/workbox-routing/_version.mjs ***!
  \***************************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\ntry{self['workbox:routing:4.3.1']&&_()}catch(e){}// eslint-disable-line\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/_version.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/workbox-routing/index.mjs ***!
  \************************************************/
/*! exports provided: NavigationRoute, RegExpRoute, registerNavigationRoute, registerRoute, Route, Router, setCatchHandler, setDefaultHandler */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var _NavigationRoute_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NavigationRoute.mjs */ \"./node_modules/workbox-routing/NavigationRoute.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NavigationRoute\", function() { return _NavigationRoute_mjs__WEBPACK_IMPORTED_MODULE_1__[\"NavigationRoute\"]; });\n\n/* harmony import */ var _RegExpRoute_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RegExpRoute.mjs */ \"./node_modules/workbox-routing/RegExpRoute.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RegExpRoute\", function() { return _RegExpRoute_mjs__WEBPACK_IMPORTED_MODULE_2__[\"RegExpRoute\"]; });\n\n/* harmony import */ var _registerNavigationRoute_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registerNavigationRoute.mjs */ \"./node_modules/workbox-routing/registerNavigationRoute.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"registerNavigationRoute\", function() { return _registerNavigationRoute_mjs__WEBPACK_IMPORTED_MODULE_3__[\"registerNavigationRoute\"]; });\n\n/* harmony import */ var _registerRoute_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./registerRoute.mjs */ \"./node_modules/workbox-routing/registerRoute.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"registerRoute\", function() { return _registerRoute_mjs__WEBPACK_IMPORTED_MODULE_4__[\"registerRoute\"]; });\n\n/* harmony import */ var _Route_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Route.mjs */ \"./node_modules/workbox-routing/Route.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Route\", function() { return _Route_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Route\"]; });\n\n/* harmony import */ var _Router_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Router.mjs */ \"./node_modules/workbox-routing/Router.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return _Router_mjs__WEBPACK_IMPORTED_MODULE_6__[\"Router\"]; });\n\n/* harmony import */ var _setCatchHandler_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./setCatchHandler.mjs */ \"./node_modules/workbox-routing/setCatchHandler.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"setCatchHandler\", function() { return _setCatchHandler_mjs__WEBPACK_IMPORTED_MODULE_7__[\"setCatchHandler\"]; });\n\n/* harmony import */ var _setDefaultHandler_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./setDefaultHandler.mjs */ \"./node_modules/workbox-routing/setDefaultHandler.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"setDefaultHandler\", function() { return _setDefaultHandler_mjs__WEBPACK_IMPORTED_MODULE_8__[\"setDefaultHandler\"]; });\n\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif (true) {\n  workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isSWEnv('workbox-routing');\n}\n\n/**\n * @namespace workbox.routing\n */\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/index.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/registerNavigationRoute.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/workbox-routing/registerNavigationRoute.mjs ***!
  \******************************************************************/
/*! exports provided: registerNavigationRoute */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerNavigationRoute\", function() { return registerNavigationRoute; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.mjs */ \"./node_modules/workbox-core/_private/cacheNames.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _NavigationRoute_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NavigationRoute.mjs */ \"./node_modules/workbox-routing/NavigationRoute.mjs\");\n/* harmony import */ var _utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/getOrCreateDefaultRouter.mjs */ \"./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n/**\n * Registers a route that will return a precached file for a navigation\n * request. This is useful for the\n * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\n *\n * When determining the URL of the precached HTML document, you will likely need\n * to call `workbox.precaching.getCacheKeyForURL(originalUrl)`, to account for\n * the fact that Workbox's precaching naming conventions often results in URL\n * cache keys that contain extra revisioning info.\n *\n * This method will generate a\n * [NavigationRoute]{@link workbox.routing.NavigationRoute}\n * and call\n * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute} on a\n * singleton Router instance.\n *\n * @param {string} cachedAssetUrl The cache key to use for the HTML file.\n * @param {Object} [options]\n * @param {string} [options.cacheName] Cache name to store and retrieve\n * requests. Defaults to precache cache name provided by\n * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\n * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\n * match, the route will not handle the request (even if a whitelist entry\n * matches).\n * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n * match the URL's pathname and search parameter, the route will handle the\n * request (assuming the blacklist doesn't match).\n * @return {workbox.routing.NavigationRoute} Returns the generated\n * Route.\n *\n * @alias workbox.routing.registerNavigationRoute\n */\nconst registerNavigationRoute = (cachedAssetUrl, options = {}) => {\n  if (true) {\n    workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isType(cachedAssetUrl, 'string', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerNavigationRoute',\n      paramName: 'cachedAssetUrl',\n    });\n  }\n\n  const cacheName = workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__[\"cacheNames\"].getPrecacheName(options.cacheName);\n  const handler = async () => {\n    try {\n      const response = await caches.match(cachedAssetUrl, {cacheName});\n\n      if (response) {\n        return response;\n      }\n\n      // This shouldn't normally happen, but there are edge cases:\n      // https://github.com/GoogleChrome/workbox/issues/1441\n      throw new Error(`The cache ${cacheName} did not have an entry for ` +\n          `${cachedAssetUrl}.`);\n    } catch (error) {\n      // If there's either a cache miss, or the caches.match() call threw\n      // an exception, then attempt to fulfill the navigation request with\n      // a response from the network rather than leaving the user with a\n      // failed navigation.\n      if (true) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].debug(`Unable to respond to navigation request with ` +\n            `cached response. Falling back to network.`, error);\n      }\n\n      // This might still fail if the browser is offline...\n      return fetch(cachedAssetUrl);\n    }\n  };\n\n  const route = new _NavigationRoute_mjs__WEBPACK_IMPORTED_MODULE_3__[\"NavigationRoute\"](handler, {\n    whitelist: options.whitelist,\n    blacklist: options.blacklist,\n  });\n\n  const defaultRouter = Object(_utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_4__[\"getOrCreateDefaultRouter\"])();\n  defaultRouter.registerRoute(route);\n\n  return route;\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/registerNavigationRoute.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/registerRoute.mjs":
/*!********************************************************!*\
  !*** ./node_modules/workbox-routing/registerRoute.mjs ***!
  \********************************************************/
/*! exports provided: registerRoute */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerRoute\", function() { return registerRoute; });\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _Route_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route.mjs */ \"./node_modules/workbox-routing/Route.mjs\");\n/* harmony import */ var _RegExpRoute_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RegExpRoute.mjs */ \"./node_modules/workbox-routing/RegExpRoute.mjs\");\n/* harmony import */ var _utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/getOrCreateDefaultRouter.mjs */ \"./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [Router.registerRoute()]{@link\n * workbox.routing.Router#registerRoute}.\n *\n * @param {\n * RegExp|\n * string|\n * workbox.routing.Route~matchCallback|\n * workbox.routing.Route\n * } capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox.routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @alias workbox.routing.registerRoute\n */\nconst registerRoute = (capture, handler, method = 'GET') => {\n  let route;\n\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location);\n\n    if (true) {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"WorkboxError\"]('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture',\n        });\n      }\n\n      // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n      const valueToCheck = capture.startsWith('http') ?\n          captureUrl.pathname : capture;\n\n      // See https://github.com/pillarjs/path-to-regexp#parameters\n      const wildcards = '[*:?+]';\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].debug(\n            `The '$capture' parameter contains an Express-style wildcard ` +\n          `character (${wildcards}). Strings are now always interpreted as ` +\n          `exact matches; use a RegExp for partial or wildcard matches.`\n        );\n      }\n    }\n\n    const matchCallback = ({url}) => {\n      if (true) {\n        if ((url.pathname === captureUrl.pathname) &&\n            (url.origin !== captureUrl.origin)) {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].debug(\n              `${capture} only partially matches the cross-origin URL ` +\n              `${url}. This route will only handle cross-origin requests ` +\n              `if they match the entire URL.`);\n        }\n      }\n\n      return url.href === captureUrl.href;\n    };\n\n    route = new _Route_mjs__WEBPACK_IMPORTED_MODULE_2__[\"Route\"](matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    route = new _RegExpRoute_mjs__WEBPACK_IMPORTED_MODULE_3__[\"RegExpRoute\"](capture, handler, method);\n  } else if (typeof capture === 'function') {\n    route = new _Route_mjs__WEBPACK_IMPORTED_MODULE_2__[\"Route\"](capture, handler, method);\n  } else if (capture instanceof _Route_mjs__WEBPACK_IMPORTED_MODULE_2__[\"Route\"]) {\n    route = capture;\n  } else {\n    throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"WorkboxError\"]('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture',\n    });\n  }\n\n  const defaultRouter = Object(_utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_4__[\"getOrCreateDefaultRouter\"])();\n  defaultRouter.registerRoute(route);\n\n  return route;\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/registerRoute.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/setCatchHandler.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-routing/setCatchHandler.mjs ***!
  \**********************************************************/
/*! exports provided: setCatchHandler */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setCatchHandler\", function() { return setCatchHandler; });\n/* harmony import */ var _utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreateDefaultRouter.mjs */ \"./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n/**\n * If a Route throws an error while handling a request, this `handler`\n * will be called and given a chance to provide a response.\n *\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @alias workbox.routing.setCatchHandler\n */\nconst setCatchHandler = (handler) => {\n  const defaultRouter = Object(_utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_0__[\"getOrCreateDefaultRouter\"])();\n  defaultRouter.setCatchHandler(handler);\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/setCatchHandler.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/setDefaultHandler.mjs":
/*!************************************************************!*\
  !*** ./node_modules/workbox-routing/setDefaultHandler.mjs ***!
  \************************************************************/
/*! exports provided: setDefaultHandler */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDefaultHandler\", function() { return setDefaultHandler; });\n/* harmony import */ var _utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreateDefaultRouter.mjs */ \"./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n/**\n * Define a default `handler` that's called when no routes explicitly\n * match the incoming request.\n *\n * Without a default handler, unmatched requests will go against the\n * network as if there were no service worker present.\n *\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @alias workbox.routing.setDefaultHandler\n */\nconst setDefaultHandler = (handler) => {\n  const defaultRouter = Object(_utils_getOrCreateDefaultRouter_mjs__WEBPACK_IMPORTED_MODULE_0__[\"getOrCreateDefaultRouter\"])();\n  defaultRouter.setDefaultHandler(handler);\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/setDefaultHandler.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/utils/constants.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-routing/utils/constants.mjs ***!
  \**********************************************************/
/*! exports provided: defaultMethod, validMethods */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultMethod\", function() { return defaultMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validMethods\", function() { return validMethods; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nconst defaultMethod = 'GET';\n\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nconst validMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'PATCH',\n  'POST',\n  'PUT',\n];\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/utils/constants.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs ***!
  \*************************************************************************/
/*! exports provided: getOrCreateDefaultRouter */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOrCreateDefaultRouter\", function() { return getOrCreateDefaultRouter; });\n/* harmony import */ var _Router_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Router.mjs */ \"./node_modules/workbox-routing/Router.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\nlet defaultRouter;\n\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nconst getOrCreateDefaultRouter = () => {\n  if (!defaultRouter) {\n    defaultRouter = new _Router_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Router\"]();\n\n    // The helpers that use the default Router assume these listeners exist.\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n  }\n  return defaultRouter;\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/utils/normalizeHandler.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/workbox-routing/utils/normalizeHandler.mjs ***!
  \*****************************************************************/
/*! exports provided: normalizeHandler */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeHandler\", function() { return normalizeHandler; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-routing/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nconst normalizeHandler = (handler) => {\n  if (handler && typeof handler === 'object') {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].hasMethod(handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return handler;\n  } else {\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isType(handler, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return {handle: handler};\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-routing/utils/normalizeHandler.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/CacheFirst.mjs":
/*!********************************************************!*\
  !*** ./node_modules/workbox-strategies/CacheFirst.mjs ***!
  \********************************************************/
/*! exports provided: CacheFirst */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CacheFirst\", function() { return CacheFirst; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.mjs */ \"./node_modules/workbox-core/_private/cacheNames.mjs\");\n/* harmony import */ var workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/cacheWrapper.mjs */ \"./node_modules/workbox-core/_private/cacheWrapper.mjs\");\n/* harmony import */ var workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/fetchWrapper.mjs */ \"./node_modules/workbox-core/_private/fetchWrapper.mjs\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.mjs */ \"./node_modules/workbox-core/_private/getFriendlyURL.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/messages.mjs */ \"./node_modules/workbox-strategies/utils/messages.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__[\"cacheNames\"].getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    let response = await workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"cacheWrapper\"].match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    let error;\n    if (!response) {\n      if (true) {\n        logs.push(\n            `No response found in the '${this._cacheName}' cache. ` +\n          `Will respond with a network request.`);\n      }\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (true) {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (true) {\n        logs.push(\n            `Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (true) {\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].groupCollapsed(\n          _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__[\"messages\"].strategyStart('CacheFirst', request));\n      for (let log of logs) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log(log);\n      }\n      _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__[\"messages\"].printFinalResponse(response);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].groupEnd();\n    }\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"WorkboxError\"]('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork(request, event) {\n    const response = await workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__[\"fetchWrapper\"].fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    // Keep the service worker while we put the request to the cache\n    const responseClone = response.clone();\n    const cachePutPromise = workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"cacheWrapper\"].put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (true) {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${Object(workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_4__[\"getFriendlyURL\"])(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/CacheFirst.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/CacheOnly.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/workbox-strategies/CacheOnly.mjs ***!
  \*******************************************************/
/*! exports provided: CacheOnly */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CacheOnly\", function() { return CacheOnly; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.mjs */ \"./node_modules/workbox-core/_private/cacheNames.mjs\");\n/* harmony import */ var workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/cacheWrapper.mjs */ \"./node_modules/workbox-core/_private/cacheWrapper.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/messages.mjs */ \"./node_modules/workbox-strategies/utils/messages.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheOnly {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__[\"cacheNames\"].getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheOnly',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    const response = await workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"cacheWrapper\"].match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    if (true) {\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].groupCollapsed(\n          _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_5__[\"messages\"].strategyStart('CacheOnly', request));\n      if (response) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(`Found a cached response in the '${this._cacheName}'` +\n          ` cache.`);\n        _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_5__[\"messages\"].printFinalResponse(response);\n      } else {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(`No response found in the '${this._cacheName}' cache.`);\n      }\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].groupEnd();\n    }\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"WorkboxError\"]('no-response', {url: request.url});\n    }\n    return response;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/CacheOnly.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/NetworkFirst.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-strategies/NetworkFirst.mjs ***!
  \**********************************************************/
/*! exports provided: NetworkFirst */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkFirst\", function() { return NetworkFirst; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.mjs */ \"./node_modules/workbox-core/_private/cacheNames.mjs\");\n/* harmony import */ var workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/cacheWrapper.mjs */ \"./node_modules/workbox-core/_private/cacheWrapper.mjs\");\n/* harmony import */ var workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/fetchWrapper.mjs */ \"./node_modules/workbox-core/_private/fetchWrapper.mjs\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.mjs */ \"./node_modules/workbox-core/_private/getFriendlyURL.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/messages.mjs */ \"./node_modules/workbox-strategies/utils/messages.mjs\");\n/* harmony import */ var _plugins_cacheOkAndOpaquePlugin_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/cacheOkAndOpaquePlugin.mjs */ \"./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   * @param {number} options.networkTimeoutSeconds If set, any network requests\n   * that fail to respond within the timeout will fallback to the cache.\n   *\n   * This option can be used to combat\n   * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n   * scenarios.\n   */\n  constructor(options = {}) {\n    this._cacheName = workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__[\"cacheNames\"].getRuntimeName(options.cacheName);\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [_plugins_cacheOkAndOpaquePlugin_mjs__WEBPACK_IMPORTED_MODULE_8__[\"cacheOkAndOpaquePlugin\"], ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [_plugins_cacheOkAndOpaquePlugin_mjs__WEBPACK_IMPORTED_MODULE_8__[\"cacheOkAndOpaquePlugin\"]];\n    }\n\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds;\n    if (true) {\n      if (this._networkTimeoutSeconds) {\n        workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isType(this._networkTimeoutSeconds, 'number', {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkFirst',\n          funcName: 'constructor',\n          paramName: 'networkTimeoutSeconds',\n        });\n      }\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'NetworkFirst',\n        funcName: 'handle',\n        paramName: 'makeRequest',\n      });\n    }\n\n    const promises = [];\n    let timeoutId;\n\n    if (this._networkTimeoutSeconds) {\n      const {id, promise} = this._getTimeoutPromise({request, event, logs});\n      timeoutId = id;\n      promises.push(promise);\n    }\n\n    const networkPromise =\n        this._getNetworkPromise({timeoutId, request, event, logs});\n    promises.push(networkPromise);\n\n    // Promise.race() will resolve as soon as the first promise resolves.\n    let response = await Promise.race(promises);\n    // If Promise.race() resolved with null, it might be due to a network\n    // timeout + a cache miss. If that were to happen, we'd rather wait until\n    // the networkPromise resolves instead of returning null.\n    // Note that it's fine to await an already-resolved promise, so we don't\n    // have to check to see if it's still \"in flight\".\n    if (!response) {\n      response = await networkPromise;\n    }\n\n    if (true) {\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].groupCollapsed(\n          _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__[\"messages\"].strategyStart('NetworkFirst', request));\n      for (let log of logs) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log(log);\n      }\n      _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__[\"messages\"].printFinalResponse(response);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].groupEnd();\n    }\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"WorkboxError\"]('no-response', {url: request.url});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs array\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  _getTimeoutPromise({request, logs, event}) {\n    let timeoutId;\n    const timeoutPromise = new Promise((resolve) => {\n      const onNetworkTimeout = async () => {\n        if (true) {\n          logs.push(`Timing out the network response at ` +\n            `${this._networkTimeoutSeconds} seconds.`);\n        }\n\n        resolve(await this._respondFromCache({request, event}));\n      };\n\n      timeoutId = setTimeout(\n          onNetworkTimeout,\n          this._networkTimeoutSeconds * 1000,\n      );\n    });\n\n    return {\n      promise: timeoutPromise,\n      id: timeoutId,\n    };\n  }\n\n  /**\n   * @param {Object} options\n   * @param {number|undefined} options.timeoutId\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs Array.\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getNetworkPromise({timeoutId, request, logs, event}) {\n    let error;\n    let response;\n    try {\n      response = await workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__[\"fetchWrapper\"].fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins,\n      });\n    } catch (err) {\n      error = err;\n    }\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    if (true) {\n      if (response) {\n        logs.push(`Got response from network.`);\n      } else {\n        logs.push(`Unable to get a response from the network. Will respond ` +\n          `with a cached response.`);\n      }\n    }\n\n    if (error || !response) {\n      response = await this._respondFromCache({request, event});\n      if (true) {\n        if (response) {\n          logs.push(`Found a cached response in the '${this._cacheName}'` +\n            ` cache.`);\n        } else {\n          logs.push(`No response found in the '${this._cacheName}' cache.`);\n        }\n      }\n    } else {\n      // Keep the service worker alive while we put the request in the cache\n      const responseClone = response.clone();\n      const cachePut = workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"cacheWrapper\"].put({\n        cacheName: this._cacheName,\n        request,\n        response: responseClone,\n        event,\n        plugins: this._plugins,\n      });\n\n      if (event) {\n        try {\n          // The event has been responded to so we can keep the SW alive to\n          // respond to the request\n          event.waitUntil(cachePut);\n        } catch (err) {\n          if (true) {\n            workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${Object(workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_4__[\"getFriendlyURL\"])(request.url)}'.`);\n          }\n        }\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * Used if the network timeouts or fails to make the request.\n   *\n   * @param {Object} options\n   * @param {Request} request The request to match in the cache\n   * @param {Event} [options.event]\n   * @return {Promise<Object>}\n   *\n   * @private\n   */\n  _respondFromCache({event, request}) {\n    return workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"cacheWrapper\"].match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/NetworkFirst.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/NetworkOnly.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/workbox-strategies/NetworkOnly.mjs ***!
  \*********************************************************/
/*! exports provided: NetworkOnly */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkOnly\", function() { return NetworkOnly; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.mjs */ \"./node_modules/workbox-core/_private/cacheNames.mjs\");\n/* harmony import */ var workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/fetchWrapper.mjs */ \"./node_modules/workbox-core/_private/fetchWrapper.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/messages.mjs */ \"./node_modules/workbox-strategies/utils/messages.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkOnly {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   */\n  constructor(options = {}) {\n    this._cacheName = workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__[\"cacheNames\"].getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'NetworkOnly',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    let error;\n    let response;\n    try {\n      response = await workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"fetchWrapper\"].fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins,\n      });\n    } catch (err) {\n      error = err;\n    }\n\n    if (true) {\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].groupCollapsed(\n          _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_5__[\"messages\"].strategyStart('NetworkOnly', request));\n      if (response) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(`Got response from network.`);\n      } else {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(`Unable to get a response from the network.`);\n      }\n      _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_5__[\"messages\"].printFinalResponse(response);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].groupEnd();\n    }\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"WorkboxError\"]('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/NetworkOnly.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/StaleWhileRevalidate.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/workbox-strategies/StaleWhileRevalidate.mjs ***!
  \******************************************************************/
/*! exports provided: StaleWhileRevalidate */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaleWhileRevalidate\", function() { return StaleWhileRevalidate; });\n/* harmony import */ var workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.mjs */ \"./node_modules/workbox-core/_private/assert.mjs\");\n/* harmony import */ var workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.mjs */ \"./node_modules/workbox-core/_private/cacheNames.mjs\");\n/* harmony import */ var workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/cacheWrapper.mjs */ \"./node_modules/workbox-core/_private/cacheWrapper.mjs\");\n/* harmony import */ var workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/fetchWrapper.mjs */ \"./node_modules/workbox-core/_private/fetchWrapper.mjs\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.mjs */ \"./node_modules/workbox-core/_private/getFriendlyURL.mjs\");\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.mjs */ \"./node_modules/workbox-core/_private/WorkboxError.mjs\");\n/* harmony import */ var _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/messages.mjs */ \"./node_modules/workbox-strategies/utils/messages.mjs\");\n/* harmony import */ var _plugins_cacheOkAndOpaquePlugin_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/cacheOkAndOpaquePlugin.mjs */ \"./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass StaleWhileRevalidate {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = workbox_core_private_cacheNames_mjs__WEBPACK_IMPORTED_MODULE_1__[\"cacheNames\"].getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [_plugins_cacheOkAndOpaquePlugin_mjs__WEBPACK_IMPORTED_MODULE_8__[\"cacheOkAndOpaquePlugin\"], ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [_plugins_cacheOkAndOpaquePlugin_mjs__WEBPACK_IMPORTED_MODULE_8__[\"cacheOkAndOpaquePlugin\"]];\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (true) {\n      workbox_core_private_assert_mjs__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'StaleWhileRevalidate',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\n\n    let response = await workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"cacheWrapper\"].match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n    let error;\n    if (response) {\n      if (true) {\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\n          ` cache. Will update with the network response in the background.`);\n      }\n\n      if (event) {\n        try {\n          event.waitUntil(fetchAndCachePromise);\n        } catch (error) {\n          if (true) {\n            workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${Object(workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_4__[\"getFriendlyURL\"])(request.url)}'.`);\n          }\n        }\n      }\n    } else {\n      if (true) {\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\n          `Will wait for the network response.`);\n      }\n      try {\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        error = err;\n      }\n    }\n\n    if (true) {\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].groupCollapsed(\n          _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__[\"messages\"].strategyStart('StaleWhileRevalidate', request));\n      for (let log of logs) {\n        workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log(log);\n      }\n      _utils_messages_mjs__WEBPACK_IMPORTED_MODULE_7__[\"messages\"].printFinalResponse(response);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].groupEnd();\n    }\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"WorkboxError\"]('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork({request, event}) {\n    const response = await workbox_core_private_fetchWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__[\"fetchWrapper\"].fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    const cachePutPromise = workbox_core_private_cacheWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__[\"cacheWrapper\"].put({\n      cacheName: this._cacheName,\n      request,\n      response: response.clone(),\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (true) {\n          workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${Object(workbox_core_private_getFriendlyURL_mjs__WEBPACK_IMPORTED_MODULE_4__[\"getFriendlyURL\"])(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/StaleWhileRevalidate.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/_version.mjs":
/*!******************************************************!*\
  !*** ./node_modules/workbox-strategies/_version.mjs ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\ntry{self['workbox:strategies:4.3.1']&&_()}catch(e){}// eslint-disable-line\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/_version.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/workbox-strategies/index.mjs ***!
  \***************************************************/
/*! exports provided: CacheFirst, CacheOnly, NetworkFirst, NetworkOnly, StaleWhileRevalidate, cacheFirst, cacheOnly, networkFirst, networkOnly, staleWhileRevalidate */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheFirst\", function() { return cacheFirst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheOnly\", function() { return cacheOnly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"networkFirst\", function() { return networkFirst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"networkOnly\", function() { return networkOnly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staleWhileRevalidate\", function() { return staleWhileRevalidate; });\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _CacheFirst_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CacheFirst.mjs */ \"./node_modules/workbox-strategies/CacheFirst.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CacheFirst\", function() { return _CacheFirst_mjs__WEBPACK_IMPORTED_MODULE_1__[\"CacheFirst\"]; });\n\n/* harmony import */ var _CacheOnly_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CacheOnly.mjs */ \"./node_modules/workbox-strategies/CacheOnly.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CacheOnly\", function() { return _CacheOnly_mjs__WEBPACK_IMPORTED_MODULE_2__[\"CacheOnly\"]; });\n\n/* harmony import */ var _NetworkFirst_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NetworkFirst.mjs */ \"./node_modules/workbox-strategies/NetworkFirst.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NetworkFirst\", function() { return _NetworkFirst_mjs__WEBPACK_IMPORTED_MODULE_3__[\"NetworkFirst\"]; });\n\n/* harmony import */ var _NetworkOnly_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NetworkOnly.mjs */ \"./node_modules/workbox-strategies/NetworkOnly.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NetworkOnly\", function() { return _NetworkOnly_mjs__WEBPACK_IMPORTED_MODULE_4__[\"NetworkOnly\"]; });\n\n/* harmony import */ var _StaleWhileRevalidate_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./StaleWhileRevalidate.mjs */ \"./node_modules/workbox-strategies/StaleWhileRevalidate.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StaleWhileRevalidate\", function() { return _StaleWhileRevalidate_mjs__WEBPACK_IMPORTED_MODULE_5__[\"StaleWhileRevalidate\"]; });\n\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\nconst mapping = {\n  cacheFirst: _CacheFirst_mjs__WEBPACK_IMPORTED_MODULE_1__[\"CacheFirst\"],\n  cacheOnly: _CacheOnly_mjs__WEBPACK_IMPORTED_MODULE_2__[\"CacheOnly\"],\n  networkFirst: _NetworkFirst_mjs__WEBPACK_IMPORTED_MODULE_3__[\"NetworkFirst\"],\n  networkOnly: _NetworkOnly_mjs__WEBPACK_IMPORTED_MODULE_4__[\"NetworkOnly\"],\n  staleWhileRevalidate: _StaleWhileRevalidate_mjs__WEBPACK_IMPORTED_MODULE_5__[\"StaleWhileRevalidate\"],\n};\n\nconst deprecate = (strategy) => {\n  const StrategyCtr = mapping[strategy];\n\n  return (options) => {\n    if (true) {\n      const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].warn(`The 'workbox.strategies.${strategy}()' function has been ` +\n          `deprecated and will be removed in a future version of Workbox.\\n` +\n          `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\n    }\n    return new StrategyCtr(options);\n  };\n};\n\n/**\n * @function workbox.strategies.cacheFirst\n * @param {Object} options See the {@link workbox.strategies.CacheFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheFirst = deprecate('cacheFirst');\n\n/**\n * @function workbox.strategies.cacheOnly\n * @param {Object} options See the {@link workbox.strategies.CacheOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheOnly = deprecate('cacheOnly');\n\n/**\n * @function workbox.strategies.networkFirst\n * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkFirst = deprecate('networkFirst');\n\n/**\n * @function workbox.strategies.networkOnly\n * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkOnly = deprecate('networkOnly');\n\n/**\n * @function workbox.strategies.staleWhileRevalidate\n * @param {Object} options See the\n * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\n * @deprecated since v4.0.0\n */\nconst staleWhileRevalidate = deprecate('staleWhileRevalidate');\n\n/**\n * There are common caching strategies that most service workers will need\n * and use. This module provides simple implementations of these strategies.\n *\n * @namespace workbox.strategies\n */\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/index.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs ***!
  \****************************************************************************/
/*! exports provided: cacheOkAndOpaquePlugin */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheOkAndOpaquePlugin\", function() { return cacheOkAndOpaquePlugin; });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\nconst cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: ({response}) => {\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n    return null;\n  },\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/utils/messages.mjs":
/*!************************************************************!*\
  !*** ./node_modules/workbox-strategies/utils/messages.mjs ***!
  \************************************************************/
/*! exports provided: messages */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"messages\", function() { return messages; });\n/* harmony import */ var workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.mjs */ \"./node_modules/workbox-core/_private/logger.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.mjs */ \"./node_modules/workbox-strategies/_version.mjs\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nconst messages = {\n  strategyStart: (strategyName, request) => `Using ${strategyName} to ` +\n    `respond to '${getFriendlyURL(request.url)}'`,\n  printFinalResponse: (response) => {\n    if (response) {\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].groupCollapsed(`View the final response here.`);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(response);\n      workbox_core_private_logger_mjs__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].groupEnd();\n    }\n  },\n};\n\n\n//# sourceURL=webpack:///./node_modules/workbox-strategies/utils/messages.mjs?");

/***/ }),

/***/ "./src/js/sw-img.js":
/*!**************************!*\
  !*** ./src/js/sw-img.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var workbox_routing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-routing */ \"./node_modules/workbox-routing/index.mjs\");\n/* harmony import */ var workbox_strategies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-strategies */ \"./node_modules/workbox-strategies/index.mjs\");\n\r\n\r\nworkbox_routing__WEBPACK_IMPORTED_MODULE_0__[\"registerRoute\"](\r\n    new RegExp('/img/'),\r\n    new workbox_strategies__WEBPACK_IMPORTED_MODULE_1__[\"StaleWhileRevalidate\"]({\r\n        // Use a custom cache name\r\n        cacheName: 'workbox:MI_img',\r\n        plugins: [],\r\n    })\r\n);\n\n//# sourceURL=webpack:///./src/js/sw-img.js?");

/***/ })

/******/ });